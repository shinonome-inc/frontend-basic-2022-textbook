---
title: "アラートの実装"
date: "2021-12-26"
index: 140
---

いよいよ最後の課題です。ここでは新しいReactの機能を交えながら、いままで学んできたことを振り返っていきましょう。

タスクを追加するときに、タスク名が入力されていなかったら、それは明らかにタスクとして使えませんよね。
そのため、タスク名の編集が終了したとき、タスク名が空文字列であったらタスクを消去する、そんな処理を追加したいと考えます。

しかし、タスクを勝手に削除してしまうのはユーザーにとっては一瞬ぎょっとする挙動です。
ですから、「あなたのタスクは名前がついていなかったので消しましたよ」としっかり伝えてあげる必要があります。
そのために、アラートを表示する仕組みも合わせて作成します。

作成、編集するファイルは以下です。

## ディレクトリ構造

```
src
  ├ components
  | ├ Atoms
  | | └ Alert
  | |   ├ index.jsx
  | |   └ story.jsx
  | └ Organisms
  |   ├ AlertManager
  |   | └ index.jsx
  |   └ TodoCard
  |     └ index.jsx
  └ contexts
    └ alert_handler.jsx
```

## Atoms/Alertの作成

まずはアラート本体を作りましょう。

表示するテキストと、表示するかしないかはpropsで制御するとよいでしょう。

表示するときは一番外側の要素のclassを切り替えて、それぞれ切り替わるタイミングで透明度と表示位置のtransitionをかけるよう
スタイルを書きましょう。
Reactではclass名の指定はclassNameというpropsを介して行うことに注意してください。

## AlertHandlerContextの作成

Atoms/Alertは後述するOrganisms/AlertManagerの中に配置し、それはOrganisms/TodoCardと同じ階層に配置されます。
ここで、TodoCardで発生したエラーをAlertまで伝えるにはどうしたらよいでしょうか。
一つの方法は、propsにエラーが発生したときの関数を渡しておき、
それをバケツリレー式に呼び出してゆきアラートの表示を実行するというものです。
今回はコンポーネントの階層が深くないのでそれでも可能と言えば可能ですが、もっと大規模なページになったとき、
果たしてコンポーネントの階層の深くで発生したエラーを伝えるために、通り道となる全てのコンポーネントのpropsに専用の関数を
付けるのは可能でしょうか。少なくともコードが汚く読みづらいものになるでしょう。

これを解決する、コンポーネントの階層をまたいだデータの伝達を実現するものが、
ReactのContextです。

Contextの中身はざっくり言うと値とProviderに分かれています。
値は我々が好きなものを格納することができます。
一方でProviderというのはその値を仲介するためのReactコンポーネントで、
Contextとともに自動で生成されます。

実際に作って行きましょう。まず、Contextに入れる値を何にするか決めます。

このContextを通して行いたいことはAlertの操作ですので、
- Alertに表示する内容を指定し、Alertを開く関数

が必要になります。逆に、Alertの側からすると、
- 今表示中かどうか
- 表示する内容

の情報が必要です。また、Alertは時間が経ったら勝手に消えるので、
- Alertを閉じる関数

も必要ですね。含めるべき値はこれくらいとなります。

次に、Contextを実装していきます。名前はAlertHandlerContextとします。

Contextを定義するファイルの書き方はいろいろ考えられますが、
ここでは次のように書いていきます。

```
import React, { createContext, useContext, useState } from "react";

const AlertHandlerContext = createContext();

export const AlertHandlerProvider = ({ children }) => {
  const [alertState, setAlertState] = useState({
    visible: false,
    errorText: "",
  });

  const setAlert = (errorText) => {
    // TODO: ここを埋める
  };

  const closeAlert = () => {
    // TODO: ここを埋める
  };

  const contextValue = {
    ...alertState,
    setAlert: setAlert,
    closeAlert: closeAlert,
  };

  return (
    <AlertHandlerContext.Provider value={contextValue}>
      {children}
    </AlertHandlerContext.Provider>
  );
};

export const useAlertHandlerContext = () => useContext(AlertHandlerContext);

```

少し癖のある書き方なので穴埋め式としました。

AlertHandlerContextを作成し、そのProviderをラップするReactコンポーネントであるAlertHandlerProviderを
作成しています。

AlertHandlerProviderの中で先ほど考えたContextの値を作成しています。
Alertの開閉の関数の中身はstateの操作を行います。考えて書いてみましょう。

そして、useContextを呼び出すuseAlertHandlerContextも定義しています。
これによって、AlertHandlerContextそのものはexportせずに、必要な機能にのみ外部からアクセスできるようになっています。

## 
